var searchIndex = {};
searchIndex["fusionner"] = {"doc":"`fusionner` is French for merge. This tool exists to create merge commits between your watched topic branches and your target default branch.","items":[[3,"RepositoryConfiguration","fusionner","Configuration struct for the repository",null,null],[12,"uri","","URI to the repository remote.",0,null],[12,"checkout_path","","Path to checkout the repository to locally",0,null],[12,"fetch_refspecs","","Fetch refspecs to add to the repository being checked out. You should make sure that the references you are watching is covered by these refspecs",0,null],[12,"push_refspecs","","Push refspecs to add to the repository being checked out. This is not really useful at the moment because fusionner will always merge to refs/fusionner/* and automatically adds the right refspecs for you",0,null],[12,"username","","Username to authenticate with the remote",0,null],[12,"password","","Password to authenticate with the remote",0,null],[12,"key","","Path to private key to authenticate with the remote. If the remote requrests for a key and this is not specified, we will try to request the key from ssh-agent",0,null],[12,"key_passphrase","","Passphrase to the private key for authentication",0,null],[12,"signature_name","","The name to create merge commits under. If unspecified, will use the global configuration in Git. Otherwise we will use some generic one",0,null],[12,"signature_email","","The email to create merge commits under. If unspecified, will use the global configuration in Git. Otherwise we will use some generic one",0,null],[3,"Password","","A tuple struct to hold passwords. Implements `fmt::Display` and `fmt::Debug` to not leak during printing",null,null],[12,"password","","The wrapped password string",1,null],[3,"WatchReferences","","Convenience struct to hold references to watch for changes to be merged into some `target_reference`.",null,null],[0,"merger","","Contains the logic to create merge commits.",null,null],[3,"Merger","fusionner::merger","Contains the logic to create, and manage merge commits",null,null],[3,"Note","","A `Note` is stored for each commit on the topic branches' current head",null,null],[12,"_note_origin","","For human readers to know where this is from. A fixed string.",2,null],[12,"_version","","Version of the note. Currently version 1",2,null],[12,"merges","","List of merge commits for the current OID. This is a `HashMap` where the keys are the target references Because of the key, the list of Merges has the invariant that each target reference shall only have one entry each in the list of merge commits",2,null],[3,"Merge","","Denotes a single Merge commit for some target reference. Stored in a `Note`.",null,null],[12,"merge_oid","","The OID for the merge commit",3,null],[12,"target_parent_oid","","The oid on the target branch that was used for the merge commit",3,null],[12,"target_parent_reference","","Reference of the target branch parent",3,null],[12,"parents_oid","","Any other merge parents, other than the target parent",3,null],[12,"merge_reference","","The reference for the merge commit",3,null],[4,"MergeReferenceNamer","","Customise how the merge references are named.",null,null],[13,"Default","","The default namer will create a reference at `refs/fusionner/{reference}/{target}` where `{target}` is the target reference, and `{reference}~ is the reference that is being merged into target.",4,null],[13,"Custom","","Use a function that will return the name of the merge reference # Example: `use fusionner::merger::*; let cb = Box::new(move |reference : &str, target_ref : &str, _oid : _, _target_oid : _| { format!(\"refs/merge/{}/{}\", target_ref, reference) }); let namer = MergeReferenceNamer::Custom(cb);`",4,null],[4,"ShouldMergeResult","","Enum returned by `Merger::should_merge` depending on the state of affairs",null,null],[13,"Merge","","A merge is required. This variant includes a `Note` for the commit, if one exists. If one exists, a `Merge` should be appended to this. Otherwise, a new `Note` with one `Merge` should be created",5,null],[13,"ExistingMergeInSameTargetReference","","An up to date (i.e. target reference OID matches) merge commit is stored in the `Note` with the target reference exists. Nothing to do.",5,null],[13,"ExistingMergeInDifferentTargetReference","","An up to date (i.e. target reference OID matches) merge commit is stored in the `Note`. The `proposed_merge` should be merged into the note",5,null],[12,"note","fusionner::merger::ShouldMergeResult","Note found for commit",5,null],[12,"merges","","All the merges for this commit",5,null],[12,"proposed_merge","","A proposed `Merge` that should be appended to the `Note`",5,null],[6,"Merges","fusionner::merger","A `HashMap` of `Merge` where the key is a `String` corresponding to the `target_reference` of the merge. This ensures that only one merge commit per `target_reference` is tracked.",null,null],[6,"MergeReferenceNamerCallback","","Type for callback implementing custom merge reference naming. The meanings for the input arguments are: `Fn(reference: &str, target_reference: &str, oid: git2::Oid, target_oid: git2::Oid) -> String`",null,null],[11,"eq","","",2,{"inputs":[{"name":"self"},{"name":"note"}],"output":{"name":"bool"}}],[11,"ne","","",2,{"inputs":[{"name":"self"},{"name":"note"}],"output":{"name":"bool"}}],[11,"clone","","",2,{"inputs":[{"name":"self"}],"output":{"name":"note"}}],[11,"fmt","","",2,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"eq","","",3,{"inputs":[{"name":"self"},{"name":"merge"}],"output":{"name":"bool"}}],[11,"ne","","",3,{"inputs":[{"name":"self"},{"name":"merge"}],"output":{"name":"bool"}}],[11,"clone","","",3,{"inputs":[{"name":"self"}],"output":{"name":"merge"}}],[11,"fmt","","",3,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"eq","","",5,{"inputs":[{"name":"self"},{"name":"shouldmergeresult"}],"output":{"name":"bool"}}],[11,"ne","","",5,{"inputs":[{"name":"self"},{"name":"shouldmergeresult"}],"output":{"name":"bool"}}],[11,"clone","","",5,{"inputs":[{"name":"self"}],"output":{"name":"shouldmergeresult"}}],[11,"fmt","","",5,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"new","","Create a new merger.",6,{"inputs":[{"name":"repository"},{"name":"option"},{"name":"option"},{"name":"option"}],"output":{"name":"result"}}],[11,"add_note_refspecs","","Add refspecs to a remote to fetch/push commit notes, specific for fusionner This is based on the `namespace` provided when creating a new `Merger`.",6,{"inputs":[{"name":"self"}],"output":{"name":"result"}}],[11,"fetch_notes","","Fetch notes based on the `namespace` provided when creating a new `Merger` from the remote configured",6,{"inputs":[{"name":"self"}],"output":{"name":"result"}}],[11,"find_note","","Find note for commit. Make sure you have fetched them first",6,{"inputs":[{"name":"self"},{"name":"oid"}],"output":{"name":"result"}}],[11,"add_note","","Add note for the OID. Will serialise to TOML before storage. Returns OID of note.",6,{"inputs":[{"name":"self"},{"name":"note"},{"name":"oid"}],"output":{"name":"result"}}],[11,"should_merge","","Determine if a merge should be made, based on the rules below.",6,{"inputs":[{"name":"self"},{"name":"oid"},{"name":"oid"},{"name":"str"},{"name":"str"}],"output":{"name":"shouldmergeresult"}}],[11,"merge","","Performs a merge and return a `Merge` entry intended for `oid`. You should then add the `Merge` into the `Note` for `oid`.",6,{"inputs":[{"name":"self"},{"name":"oid"},{"name":"oid"},{"name":"str"},{"name":"str"}],"output":{"name":"result"}}],[11,"check_and_merge","","Convenience function to check if a merge is required, and merge if needed. Will fetch remote merge references. Will push, if desired. This function calls both `should_merge` and `merge`.",6,{"inputs":[{"name":"self"},{"name":"oid"},{"name":"oid"},{"name":"str"},{"name":"str"},{"name":"bool"}],"output":{"name":"result"}}],[11,"notes_reference","","Returns the reference for the notes that fusionner will create, based on the namespace provided when creating a new `Merger`.",6,{"inputs":[{"name":"self"}],"output":{"name":"string"}}],[11,"new","","Create a new `Note` with the list of `Merges`.",2,{"inputs":[{"name":"merges"}],"output":{"name":"note"}}],[11,"new_with_merge","","Convenience function to create a new `Note` with one `Merge`.",2,{"inputs":[{"name":"merge"}],"output":{"name":"note"}}],[11,"append_with_merge","","Appends `Merge` to the `Note`, preserving the invariant that one `Merge` exists per `target_reference`. Returns the previous `Merge` if it existed",2,{"inputs":[{"name":"self"},{"name":"merge"}],"output":{"name":"option"}}],[11,"find_matching_merges","","Find `Merge`s in the note tha corresponds to `target_oid`, regardless of their `target_reference`.",2,{"inputs":[{"name":"self"},{"name":"oid"}],"output":{"name":"hashmap"}}],[11,"new","","Creates a new `Merge`.",3,null],[11,"resolve","","Returns the name of the merge reference based on the rules provided.",4,{"inputs":[{"name":"self"},{"name":"str"},{"name":"str"},{"name":"oid"},{"name":"oid"}],"output":{"name":"string"}}],[11,"add_default_refspecs","","Add the refspecs used in the `Default` namer to the remote.",4,{"inputs":[{"name":"remote"}],"output":{"name":"result"}}],[11,"fmt","","",5,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[0,"git","fusionner","Convenience wrapper around the `git2-rs` library",null,null],[3,"Repository","fusionner::git","Repository struct to wrap around `git2::Repository`",null,null],[12,"repository","","The repository struct that is wrapped. Use this to perform operations directly on the repository",7,null],[3,"Remote","","Wraps around a `git2::Remote` struct and offers convenience methods",null,null],[12,"remote","","The wrapped remote",8,null],[3,"RemoteHead","","Cloned from a `git2::RemoteHead` without the associated lifetime. The fields correspond one to one with `git2::RemoteHead`.",null,null],[12,"is_local","","Flag if this is available locally.",9,null],[12,"oid","","",9,null],[12,"loid","","",9,null],[12,"name","","",9,null],[12,"symref_target","","",9,null],[3,"RefspecStr","","Wraps around a Refspec string to provide convenience method",null,null],[11,"clone","","",9,{"inputs":[{"name":"self"}],"output":{"name":"remotehead"}}],[11,"fmt","","",9,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",10,{"inputs":[{"name":"self"}],"output":{"name":"refspecstr"}}],[11,"fmt","","",10,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"eq","","",10,{"inputs":[{"name":"self"},{"name":"refspecstr"}],"output":{"name":"bool"}}],[11,"ne","","",10,{"inputs":[{"name":"self"},{"name":"refspecstr"}],"output":{"name":"bool"}}],[11,"flatten","","Returns a `&str` representing the reference target for this remote head. If the head is a symbolic reference, this method will resolve it.",9,{"inputs":[{"name":"self"}],"output":{"name":"str"}}],[11,"flatten_clone","","Returns a `String` representing the reference target for this remote head. If the head is a symbolic reference, this method will resolve it.",9,{"inputs":[{"name":"self"}],"output":{"name":"string"}}],[11,"new","","Create a new struct based off a `git2::Repository` and the corresponding configuration # Examples ``` extern crate git2; extern crate fusionner; extern crate tempdir;",7,{"inputs":[{"name":"repository"},{"name":"repositoryconfiguration"}],"output":{"name":"repository"}}],[11,"clone_or_open","","Convenience method to create a new struct by first attempting to open a repository at the checkout path configured, and failing that will attempt to clone from the URI configured.",7,{"inputs":[{"name":"repositoryconfiguration"}],"output":{"name":"result"}}],[11,"open","","Convenience method to create a new struct by attempting to open a repository at the checkout path configured",7,{"inputs":[{"name":"repositoryconfiguration"}],"output":{"name":"result"}}],[11,"clone","","Convenience method to create a new struct by attempting to clone a repository at a uri to the checkout path configured",7,{"inputs":[{"name":"repositoryconfiguration"}],"output":{"name":"result"}}],[11,"remote","","Returns a `Remote` struct for the remote with the given name. Defaults to the `origin` remote.",7,{"inputs":[{"name":"self"},{"name":"option"}],"output":{"name":"result"}}],[11,"signature","","Returns a signature struct for use in operations like commit. Will first check if this is available in the configuration. If not, we will attempt to find the global git configured signature. Failing that, we will use some default fusionner signature",7,{"inputs":[{"name":"self"}],"output":{"name":"result"}}],[11,"disconnect","","Disconnect from the remote",8,{"inputs":[{"name":"self"}],"output":null}],[11,"name","","Returns the name of a remote. Will return `None` for annonymous remotes",8,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"refspecs","","Returns the list of refspecs configured for the remote",8,{"inputs":[{"name":"self"}],"output":{"name":"refspecs"}}],[11,"remote_ls","","Performs a `git ls-remote` operation",8,{"inputs":[{"name":"self"}],"output":{"name":"result"}}],[11,"head","","Get the remote reference of renote HEAD (i.e. default branch)",8,{"inputs":[{"name":"self"}],"output":{"name":"result"}}],[11,"resolve_head","","Resolve the remote HEAD (i.e. default branch) from a list of heads and return the remote reference",8,null],[11,"fetch","","Fetch the list of refspecs from the remote.",8,null],[11,"push","","Attempt to push to the remote for the given list of refspecs",8,null],[11,"generate_refspec","","For a given local reference, generate a refspec for the remote with the same path on remote i.e. refs/pulls/*  --> refs/pulls/:refs/remotes/origin/pulls/",8,{"inputs":[{"name":"self"},{"name":"str"},{"name":"bool"}],"output":{"name":"result"}}],[11,"add_refspec","","Add refspec for the remote, if they don't exist.",8,{"inputs":[{"name":"self"},{"name":"str"},{"name":"direction"}],"output":{"name":"result"}}],[11,"add_refspecs","","Convenience method to add multiple refspecs at once",8,null],[11,"resolve_target_ref","","Given a reference string, attempt to find a matching remote reference. If `None` is provided, will attempt to resolve the remote's `HEAD` (usually `refs/heads/master`)",8,{"inputs":[{"name":"self"},{"name":"option"}],"output":{"name":"result"}}],[11,"find_matching_refspec","","Find if a refspec exists in a list of refspecs, usually retrieved from a repository or a remote",8,{"inputs":[{"name":"refspecs"},{"name":"direction"},{"name":"str"}],"output":{"name":"option"}}],[11,"direction_eq","","Convenience method to check if two `git2::Direction` enums are equal",8,{"inputs":[{"name":"direction"},{"name":"direction"}],"output":{"name":"bool"}}],[11,"from_str","","Construct this struct from a `&str`.",10,{"inputs":[{"name":"str"}],"output":{"name":"refspecstr"}}],[11,"force","","Check if the refspec has the force flag set",10,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"refspec","","Return the raw refspec (without the `+`)",10,{"inputs":[{"name":"self"}],"output":{"name":"str"}}],[11,"set_force","","Set the refspec to be `forced`. i.e. prepend a `+`",10,{"inputs":[{"name":"self"},{"name":"bool"}],"output":null}],[11,"to_string","","Converts the struct to a String.",10,{"inputs":[{"name":"self"}],"output":{"name":"string"}}],[11,"src","","Returns the `src` part of the refspec",10,{"inputs":[{"name":"self"}],"output":{"name":"string"}}],[11,"dest","","Returns the `dest` part of the refspec if it exists",10,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"as_forced","","Convenience function to take a refspec `&str` and turn it into a forced version # Examples ``` use fusionner::git::RefspecStr;",10,{"inputs":[{"name":"str"}],"output":{"name":"string"}}],[11,"fmt","","",10,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"eq","fusionner","",0,{"inputs":[{"name":"self"},{"name":"repositoryconfiguration"}],"output":{"name":"bool"}}],[11,"ne","","",0,{"inputs":[{"name":"self"},{"name":"repositoryconfiguration"}],"output":{"name":"bool"}}],[11,"clone","","",0,{"inputs":[{"name":"self"}],"output":{"name":"repositoryconfiguration"}}],[11,"fmt","","",0,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"partial_cmp","","",1,{"inputs":[{"name":"self"},{"name":"password"}],"output":{"name":"option"}}],[11,"lt","","",1,{"inputs":[{"name":"self"},{"name":"password"}],"output":{"name":"bool"}}],[11,"le","","",1,{"inputs":[{"name":"self"},{"name":"password"}],"output":{"name":"bool"}}],[11,"gt","","",1,{"inputs":[{"name":"self"},{"name":"password"}],"output":{"name":"bool"}}],[11,"ge","","",1,{"inputs":[{"name":"self"},{"name":"password"}],"output":{"name":"bool"}}],[11,"eq","","",1,{"inputs":[{"name":"self"},{"name":"password"}],"output":{"name":"bool"}}],[11,"ne","","",1,{"inputs":[{"name":"self"},{"name":"password"}],"output":{"name":"bool"}}],[11,"clone","","",1,{"inputs":[{"name":"self"}],"output":{"name":"password"}}],[11,"new","","Create a new password struct",1,{"inputs":[{"name":"str"}],"output":{"name":"password"}}],[11,"fmt","","",1,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"fmt","","",1,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"deref","","",1,{"inputs":[{"name":"self"}],"output":{"name":"str"}}],[11,"from_str","","",1,{"inputs":[{"name":"str"}],"output":{"name":"result"}}],[11,"fmt","","",11,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"new","","Create watch references based on a list of exact references, or some regular expressions that will match to references.",11,null],[11,"resolve_watch_refs","","Given a set of Remote heads as advertised by the remote, return a set of remtoe heads which exist based on the watch references",11,null]],"paths":[[3,"RepositoryConfiguration"],[3,"Password"],[3,"Note"],[3,"Merge"],[4,"MergeReferenceNamer"],[4,"ShouldMergeResult"],[3,"Merger"],[3,"Repository"],[3,"Remote"],[3,"RemoteHead"],[3,"RefspecStr"],[3,"WatchReferences"]]};
initSearch(searchIndex);
